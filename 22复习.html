<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
### 面向对象的三大特性
	·封装
	·继承
		自己没有的，拿别人的过来用
	·多态
		父类引用指向子类的对象（js中用不到）

### 创建对象的四种方式
	·使用字面量创建对象
	···js
		var o = {key:value,key:value}
		缺点：用一个建一个，资源浪费
	···

	·使用内置构造函数创建对象
		var o = new Object();
		var o = new Array();
		缺点：创建出来的都是空的对象，要手动添加，代码重复

	·封装简单的工厂函数（不推荐使用）
		function createObj(){
			var obj = {};
			obj.xxx= xxx;
			return obj;
	}

	`自定义构造函数
	function X {
	this.xxx=xxx;
	//```
}
	1.构造函数一般和new关键词一起使用
	2.首字母大写
	3.构造函数返回值默认为新创建好的对象，如果手动返回基本对象数据类型
	，不影响，还是默认返回值，如果返回的是对象，那么新创建出来的对象是不会
	返回，取而代之的是reurn后面的对象

	构造函数步骤
	1.new关键字创建对象
	2.调用构造函数，将new创建出来的对象赋值给构造函数的this
	3.使用this给新创建出来的对象增加成员
	4.默认返回新创建出来的这个对象

### 原型
#### 1.构造函数存在的问题
	构造函数中的方法，在每次新创建一个对象的时候，该对象都会重新的创建一次这个方法，每个对象独占一个，但是该方法内容完全一样，这样造成了资源浪费

	解决办法
	1.将构造函数内的方法，进行提取，放在构造函数外面，在构造函数外面进行引用赋值，那么创建出来的对象都会指向构造函数外面的这个函数，达到共享的目的

	缺点：全局变量增多，造成污染 2.代码结构混乱，不好维护

#### 2.使用原型
	什么是原型：构造函数在创建的时候，系统会默认的创建并关联一个对象，这个对象就是原型，默认是空对象，里面有个contstrucor属性指向构造函数

#### 3.原型的作用
	1.原型对象中的成员可以被使用和它关联的构造函数创建出来的所有对象共享

#### 4.原型对象的使用
	1.使用对象的动态特性，为原型对象添加成员
	2.直接替换原型对象

	注意事项⚠️：
		直接替换原型对象，会导致替换之前创建的对象的原型 和 替换之后创建的对象的原型 不一致

#### 5.原型的使用注意事项：
		1.使用对象访问属性的时候，会在对象中查找，如果找到了就使用，如果没找到就会去原型中进行查找
		2.使用对象设置属性的时候，不会在原型中查找，不会去原型中查找，如果在对象本身中没有找到这个属性，则给该对象新增一个属性。如果对象中有这个属性，则进行修改
		3.如果在原型对象中有引用类型的属性，那么使用对象进行修改该属性内容的时候，则其他所有跟这个原型对象相关的对象 都会受到印象

		Person.prototype.car = {};
		var p = new Person();
		p.car = {};//这是修改属性
		p.car.brand=""; //这是修改属性的内容

		4.一般情况下，不会将属性添加到原型对象中，只会将需要共享的方法添加到原型对象中
#### 6.__proto__
	1.这个属性不是标准属性，所以存在通用性问题
	2.一般不推荐使用这个属性
	3.调试到时候可以使用
	4.这个属性是原型中的属性

#### 7.替换原型的时候的注意事项：
	在新替换的原型中，没有contructor属性，会影响三角结构关系的合理性
	所以，在新替换的原型中，手动添加contructor属性










</body>
</html>